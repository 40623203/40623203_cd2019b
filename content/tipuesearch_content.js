var tipuesearch = {"pages": [{'title': '執行規劃', 'text': '', 'tags': '', 'url': '執行規劃.html'}, {'title': '手足球系統模擬', 'text': '專案成果摘要 \n 我們這學期是做手足球的模擬，用 onshape 做協同設計，將繪製好的立體圖檔轉成 STL，丟到 vrep 進行動態模擬。我們對 " 人對人 "，" 人對電腦 "， " 電腦對電腦 " 及 " 送球機構 " 的模擬寫程式，使得手足球對打都能順利地模擬，送球機構採用升降台進行送球運動，在 vrep 模擬上也遇到了不少問題，花了很多時間去嘗試，最後也有將球順利送回球場上。 \n 專案執行動機 \n 如果我們要製作一個實體的手足球，在實際製作過程中可能會遇到一些問題，例如尺寸上或是組合有一些不如預期的狀況，或是有要修改零件的地方，做出實體再做更改肯定會花更多時間，因此我們可以運用 vrep，在虛擬的地方模擬實際的情況，遇到狀況時只要修改設計圖並再次模擬就行了，這樣可以減少製作實體的時間，還不用浪費材料，可說是一舉兩得。 \n 相關文獻探討 \n Onshape introduction \n V-rep introduction \n Github introduction \n 專案執行成員 \n \n \n \n Leader \n \n Assignments \n \n \n \n \n 40623203 \n 蔡宜芳 \n \n \n 執行規劃 \n V-rep\xa0 人對人模擬和程式 \n V-rep\xa0 送球機構模擬和程式 \n \n \n \n Member \n \n Assignments \n \n \n \n \n 40623206 \n 邱妍蓁 \n \n \n Onshape 繪製手足球台跟抬球機構 \n 爆炸圖 \n \n \n \n \n 40623211 \n 王得榮 \n \n \n 標註送球機構的圖面 \n PDF \n \n \n \n \n 40623212 \n 魏有泉 \n \n 零件表 \n \n \n \n 40623216 \n 楊士平 \n \n 標註手足球的圖面 \n \n \n \n 40623221 \n 蔡和勳 \n \n 投影片 \n \n \n \n 40623222 \n 蔡博淮 \n \n 尺寸分析 \n \n \n \n 40623228 \n 陳永錩 \n \n \n V-rep\xa0 人對電腦模擬和程式 \n \n \n \n \n 40623233 \n 謝宗宏 \n \n V-rep\xa0 人對電腦模擬和程式 \n \n \n \n 40623240 \n 何冠均 \n \n PDF \n \n \n \n 40623245 \n 練峪愷 \n \n \n 標註送球機構的圖面 \n PDF \n \n \n \n \n 執行使用套件 \n Onshape： \n Onshape \xa0 is a \xa0 computer-aided design \xa0 (CAD) \xa0 software \xa0 system, delivered over the Internet via a \xa0 Software as a Service \xa0 (SAAS) model. It makes extensive use of \xa0 cloud computing , with compute-intensive processing and \xa0 rendering \xa0 performed on \xa0 Internet -based \xa0 servers , and users are able to interact with the system via a \xa0 web browser \xa0 or the \xa0 iOS \xa0 and \xa0 Android \xa0 apps. \n Onshape allows teams to collaborate on a single shared design, the same way multiple writers can work together editing a shared document via cloud services. \xa0 It is primarily focused on mechanical CAD (MCAD) and is used for product and machinery design across many industries, including \xa0 consumer electronics , mechanical \xa0 machinery , \xa0 medical devices , \xa0 3D printing , machine parts, and industrial equipment. \n Onshape upgrades are released directly to the web interface, and the software does not require maintenance work from the user. \n Founded in 2012, Onshape is based in \xa0 Cambridge, Massachusetts \xa0 (USA), with offices in \xa0 Singapore \xa0 and \xa0 Pune, India . \xa0 Its leadership team includes several engineers and executives who originated \xa0 SolidWorks , a popular 3D CAD program that runs on Windows computers. \xa0 Onshape’s co-founders include two former SolidWorks CEOs, \xa0 Jon Hirschtick \xa0 and John McEleney. \n V-rep： \n \n V-REP provides a unified framework combining many powerful internal and external libraries that are often useful for robotics simulations. This includes dynamic simulation engines, forward/inverse kinematics tools, collision detection libraries, vision sensor simulations, path planning, GUI development tools, and built-in models of many common robots \n V-REP is highly extensible. V-REP developers provide an API that allows one to write custom plugins that add new features. You can embed \xa0 Lua \xa0 scripts directly into a simulation scene that, for example, process simulated sensor data, run control algorithms, implement user interfaces, or even send data to a physical robot. They also provide a remote API that allows one to develop standalone applications in many programming languages that are able to pass data in and out of a running V-REP simulation. \n \n Github： \n GitHub 是透過 Git 進行 版本控制 的軟體原始碼代管服務平台，由GitHub公司（曾稱Logical Awesome）的開發者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用 Ruby on Rails 編寫而成。 \n GitHub同時提供付費帳戶和免費帳戶。這兩種帳戶都可以建立公開或私有的程式碼倉庫，但付費用戶支援更多功能。根據在2009年的Git用戶調查，GitHub是最流行的Git存取站點。 [3] 除了允許個人和組織建立和存取保管中的程式碼以外，它也提供了一些方便社會化共同軟體開發的功能，即一般人口中的社群功能，包括允許用戶追蹤其他用戶、組織、軟體庫的動態，對軟體程式碼的改動和bug提出評論等。GitHub也提供了圖表功能，用於概觀顯示開發者們怎樣在程式碼庫上工作以及軟體的開發活躍程度。 \n 專案執行過程規劃 \n 尋找資料 --> 分配工作 --> 執行各自工作 --> 與各組員討論問題 --> 實踐想法 -->\xa0 Onshape 組合\xa0 --> V-rep 模擬 --> lua 程式撰寫 --> 製作 PDF -->完成 \n 專案執行內容 \n 專案結論', 'tags': '', 'url': '手足球系統模擬.html'}, {'title': 'V-rep 動態模擬', 'text': '', 'tags': '', 'url': 'V-rep 動態模擬.html'}, {'title': '送球機構模擬', 'text': '機構模擬測試 \n \n Ball sending not finish simulation \n \n 送球機構左右進洞 \n \n', 'tags': '', 'url': '送球機構模擬.html'}, {'title': '送球機構程式', 'text': '利用感測器感測到球，使平台下降到下方的感測器，球滾入後，平台上升，回到場內，繼續競賽 \n function sysCall_init()\n-- 定義參數\n    slider=sim.getObjectHandle(\'drive\')\n-- 定義物件 drive 驅動軸為 slider\n    down_Sensor=sim.getObjectHandle("sensor")\n-- 定義物件 sensor 感測器為 down_Sensor\n    down_Sensor_1=sim.getObjectHandle("sensor1")\n-- 定義物件 sensor1 感測器為 down_Sensor_1\n    up_Sensor=sim.getObjectHandle("sensor0")\n-- 定義物件 sensor0 感測器為 up_Sensor\n    speed=0\n-- 初始速度參數\n    A=-1\n-- 初始值\n    b=-1\n-- 初始值\nend\n\nfunction sysCall_actuation()\n    down=sim.readProximitySensor(down_Sensor)\n-- down 讀取 down_Sensor 感測器的狀態\n    down_1=sim.readProximitySensor(down_Sensor_1)\n-- down_1 讀取 down_Sensor_1 感測器的狀態\n    up=sim.readProximitySensor(up_Sensor)\n-- up 讀取 up_Sensor 感測器的狀態\n    if (down>0) or (down_1>0) \n-- 當感測器 down 或 down_1 觸發\n        then A=sim.getSimulationTime()+3 \n-- 設定 A = 模擬時間 + 3 秒 \n    end\n    if (A>0) \n        then sim.setJointTargetVelocity(slider,speed-0.08)\n-- slider 就會以速度 -0.08 向下移動\n    end\n    if (up>0) \n-- 當感測器 up 觸發\n        then b=sim.getSimulationTime()+3 \n-- 設定 b = 模擬時間 + 3 秒 \n    end\n    if (b>0) \n        then sim.setJointTargetVelocity(slider,speed+0.01)\n-- slider 就會以速度 0.01 向上移動\n    end\nend \n \n', 'tags': '', 'url': '送球機構程式.html'}, {'title': '手足球人對人模擬', 'text': '手足球模擬系統功能展示 (模擬展示與說明影片) \n 人對人模擬 \n \n 完成品對打 \n \n left player simulation \n \n left player finish simulation \n \n left and right player simulation \n \n left1 and 2 player simulation \n \n Foosball \n \n Foosball - 測試雙人對打加送球機構 \n', 'tags': '', 'url': '手足球人對人模擬.html'}, {'title': '手足球人對人程式', 'text': 'left1 and left2\xa0Program \n -- model in Solvespace 500 mm = 5000 mm in V-rep\n--[[\nSimulation is 10 times of realistic environment\nfloor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep\nball is in Solivespace 1g (0.001) = 0.01 kg in V-rep\nhammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)\n]]\n\nthreadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==119) then\n                    -- up key\n                    velocity=100\n                    torque=200\n                    hammer_back = 0\n                end\n                if (auxiliaryData[1]==115) then\n                    -- down key\n                     hammer_back = 1\n                     torque=-200\n                     velocity = -100\n                end\n                if (auxiliaryData[1]==97) then\n                    -- right key\n                     sliding = sliding + 0.005\n                     sliding_1 = sliding_1 + 0.005\nsim.addStatusbarMessage(\'sliding:\'..sliding)\nsim.addStatusbarMessage(\'sliding_1:\'..sliding_1)  \n                end\n                if (auxiliaryData[1]==100) then\n                    -- left key\n                     sliding = sliding - 0.005\n                     sliding_1 = sliding_1 - 0.005\nsim.addStatusbarMessage(\'sliding:\'..sliding)\nsim.addStatusbarMessage(\'sliding_1:\'..sliding_1) \n                end\n                if (sliding < -0.0445) then\n                    sliding = -0.0445\n                elseif (sliding > 0.0445) then\n                    sliding = 0.0445\n                end\n                if (sliding_1 < -0.08255) then\n                    sliding_1 = -0.08255\n                elseif (sliding_1 > 0.08255) then\n                    sliding_1 = 0.08255\n                end\n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n \n        -- We take care of setting the desired hammer position:\n        if hammer_back == 1\n            then \n               sim.setJointPosition(joint, -1, orientation)\n               sim.setJointPosition(joint_1, -1, orientation)\n               --sim.setObjectPosition(hammer, -1, position)\n        end\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointTargetPosition(joint_1, velocity)\n        --sim.setJointForce(joint,torque)\n        sim.setJointTargetPosition(slider, sliding)\n        sim.setJointTargetPosition(slider_1, sliding_1)\n\n        -- Since this script is threaded, don\'t waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle(\'left_joint\')\nhammer=sim.getObjectHandle(\'left_player\')\nslider=sim.getObjectHandle("left_slider")\njoint_1=sim.getObjectHandle(\'left_joint_1\')\nhammer_1=sim.getObjectHandle(\'left_player_1\')\nslider_1=sim.getObjectHandle("left_slider_1")\nvelocity=0\nhammer_back=0\ntorque=0\nsliding = 0\nsliding_1 = 0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer, -1)\nslider_position=sim.getJointPosition(slider, -1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage(\'Lua runtime error: \'..err)\nend \n left3 and left4  \xa0Program \n -- model in Solvespace 500 mm = 5000 mm in V-rep\n--[[\nSimulation is 10 times of realistic environment\nfloor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep\nball is in Solivespace 1g (0.001) = 0.01 kg in V-rep\nhammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)\n]]\n\nthreadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==117) then\n                    -- up key\n                    velocity=100\n                    torque=200\n                    hammer_back = 0\n                end\n                if (auxiliaryData[1]==106) then\n                    -- down key\n                     hammer_back = 1\n                     torque=-200\n                     velocity = -100\n                end\n                if (auxiliaryData[1]==107) then\n                    -- right key\n                     sliding_2 = sliding_2 + 0.005\n                     sliding_3 = sliding_3 + 0.005\nsim.addStatusbarMessage(\'sliding_2:\'..sliding_2)\nsim.addStatusbarMessage(\'sliding_3:\'..sliding_3)  \n                end\n                if (auxiliaryData[1]==104) then\n                    -- left key\n                     sliding_2 = sliding_2 - 0.005\n                     sliding_3 = sliding_3 - 0.005\nsim.addStatusbarMessage(\'sliding_2:\'..sliding_2)\nsim.addStatusbarMessage(\'sliding_3:\'..sliding_3) \n                end\n                if (sliding_2 < -0.01905) then\n                    sliding_2 = -0.01905\n                elseif (sliding_2 > 0.01905) then\n                    sliding_2 = 0.01905\n                end\n                if (sliding_3 < -0.0635) then\n                    sliding_3 = -0.0635\n                elseif (sliding_3 > 0.0635) then\n                    sliding_3 = 0.0635\n                end\n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n \n        -- We take care of setting the desired hammer position:\n        if hammer_back == 1\n            then \n               sim.setJointPosition(joint, -1, orientation)\n               sim.setJointPosition(joint_1, -1, orientation)\n               --sim.setObjectPosition(hammer, -1, position)\n        end\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointTargetPosition(joint_1, velocity)\n        --sim.setJointForce(joint,torque)\n        sim.setJointTargetPosition(slider, sliding_2)\n        sim.setJointTargetPosition(slider_1, sliding_3)\n\n        -- Since this script is threaded, don\'t waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle(\'left_joint_2\')\nhammer=sim.getObjectHandle(\'left_player_2\')\nslider=sim.getObjectHandle("left_slider_2")\njoint_1=sim.getObjectHandle(\'left_joint_3\')\nhammer_1=sim.getObjectHandle(\'left_player_3\')\nslider_1=sim.getObjectHandle("left_slider_3")\nvelocity=0\nhammer_back=0\ntorque=0\nsliding_2 = 0\nsliding_3 = 0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer, -1)\nslider_position=sim.getJointPosition(slider, -1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage(\'Lua runtime error: \'..err)\nend \n right1 and right2 Program \n -- model in Solvespace 500 mm = 5000 mm in V-rep\n--[[\nSimulation is 10 times of realistic environment\nfloor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep\nball is in Solivespace 1g (0.001) = 0.01 kg in V-rep\nhammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)\n]]\n\nthreadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==2007) then\n                    -- up key\n                    velocity=100\n                    torque=200\n                    hammer_back = 0\n                end\n                if (auxiliaryData[1]==2008) then\n                    -- down key\n                     hammer_back = 1\n                     torque=-200\n                     velocity = -100\n                end\n                if (auxiliaryData[1]==2010) then\n                    -- right key\n                     sliding = sliding + 0.005\n                     sliding_1 = sliding_1 + 0.005\nsim.addStatusbarMessage(\'sliding:\'..sliding)\nsim.addStatusbarMessage(\'sliding_1:\'..sliding_1)  \n                end\n                if (auxiliaryData[1]==2009) then\n                    -- left key\n                     sliding = sliding - 0.005\n                     sliding_1 = sliding_1 - 0.005\nsim.addStatusbarMessage(\'sliding:\'..sliding)\nsim.addStatusbarMessage(\'sliding_1:\'..sliding_1) \n                end\n                if (sliding < -0.0445) then\n                    sliding = -0.0445\n                elseif (sliding > 0.0445) then\n                    sliding = 0.0445\n                end\n                if (sliding_1 < -0.08255) then\n                    sliding_1 = -0.08255\n                elseif (sliding_1 > 0.08255) then\n                    sliding_1 = 0.08255\n                end\n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n \n        -- We take care of setting the desired hammer position:\n        if hammer_back == 1\n            then \n               sim.setJointPosition(joint, -1, orientation)\n               sim.setJointPosition(joint_1, -1, orientation)\n               --sim.setObjectPosition(hammer, -1, position)\n        end\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointTargetPosition(joint_1, velocity)\n        --sim.setJointForce(joint,torque)\n        sim.setJointTargetPosition(slider, sliding)\n        sim.setJointTargetPosition(slider_1, sliding_1)\n\n        -- Since this script is threaded, don\'t waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle(\'right_joint\')\nhammer=sim.getObjectHandle(\'right_player\')\nslider=sim.getObjectHandle("right_slider")\njoint_1=sim.getObjectHandle(\'right_joint_1\')\nhammer_1=sim.getObjectHandle(\'right_player_1\')\nslider_1=sim.getObjectHandle("right_slider_1")\nvelocity=0\nhammer_back=0\ntorque=0\nsliding = 0\nsliding_1 = 0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer, -1)\nslider_position=sim.getJointPosition(slider, -1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage(\'Lua runtime error: \'..err)\nend \n left3 and left4 Program \n -- model in Solvespace 500 mm = 5000 mm in V-rep\n--[[\nSimulation is 10 times of realistic environment\nfloor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep\nball is in Solivespace 1g (0.001) = 0.01 kg in V-rep\nhammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)\n]]\n\nthreadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==56) then\n                    -- up key\n                    velocity=100\n                    torque=200\n                    hammer_back = 0\n                end\n                if (auxiliaryData[1]==53) then\n                    -- down key\n                     hammer_back = 1\n                     torque=-200\n                     velocity = -100\n                end\n                if (auxiliaryData[1]==54) then\n                    -- right key\n                     sliding_2 = sliding_2 + 0.005\n                     sliding_3 = sliding_3 + 0.005\nsim.addStatusbarMessage(\'sliding_2:\'..sliding_2)\nsim.addStatusbarMessage(\'sliding_3:\'..sliding_3)  \n                end\n                if (auxiliaryData[1]==52) then\n                    -- left key\n                     sliding_2 = sliding_2 - 0.005\n                     sliding_3 = sliding_3 - 0.005\nsim.addStatusbarMessage(\'sliding_2:\'..sliding_2)\nsim.addStatusbarMessage(\'sliding_3:\'..sliding_3) \n                end\n                if (sliding_2 < -0.01905) then\n                    sliding_2 = -0.01905\n                elseif (sliding_2 > 0.01905) then\n                    sliding_2 = 0.01905\n                end\n                if (sliding_3 < -0.0635) then\n                    sliding_3 = -0.0635\n                elseif (sliding_3 > 0.0635) then\n                    sliding_3 = 0.0635\n                end\n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n \n        -- We take care of setting the desired hammer position:\n        if hammer_back == 1\n            then \n               sim.setJointPosition(joint, -1, orientation)\n               sim.setJointPosition(joint_1, -1, orientation)\n               --sim.setObjectPosition(hammer, -1, position)\n        end\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointTargetPosition(joint_1, velocity)\n        --sim.setJointForce(joint,torque)\n        sim.setJointTargetPosition(slider, sliding_2)\n        sim.setJointTargetPosition(slider_1, sliding_3)\n\n        -- Since this script is threaded, don\'t waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle(\'right_joint_2\')\nhammer=sim.getObjectHandle(\'right_player_2\')\nslider=sim.getObjectHandle("right_slider_2")\njoint_1=sim.getObjectHandle(\'right_joint_3\')\nhammer_1=sim.getObjectHandle(\'right_player_3\')\nslider_1=sim.getObjectHandle("right_slider_3")\nvelocity=0\nhammer_back=0\ntorque=0\nsliding_2 = 0\nsliding_3 = 0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer, -1)\nslider_position=sim.getJointPosition(slider, -1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage(\'Lua runtime error: \'..err)\nend \n \n', 'tags': '', 'url': '手足球人對人程式.html'}, {'title': 'Final Report', 'text': '40623203 蔡宜芳結案口頭簡報 \n \n 評分比例： \n 學員出席 (20%)： \n 20% \n Github 倉儲管理\xa0 (20%)： \n 16% \n Onshape 協同操作 (20%)： \n 6% \n V-rep 模擬 (20%)： \n 18 % \n 程式開發 (20%)： \n 18 % \n 總分：78', 'tags': '', 'url': 'Final Report.html'}]};