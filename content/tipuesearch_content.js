var tipuesearch = {"pages": [{'title': '執行規劃', 'text': '', 'tags': '', 'url': '執行規劃.html'}, {'title': '手足球系統模擬', 'text': '專案成果摘要 \n 專案執行動機 \n 相關文獻探討 \n 專案執行成員 \n \n \n \n Leader \n \n Assignments \n \n \n \n \n 40623203 \n 蔡宜芳 \n \n \n 執行規劃 \n V-rep\xa0 人對人模擬 \n \n \n \n Member \n \n Assignments \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n 執行使用套件 \n 專案執行過程規劃 \n 專案執行內容 \n 專案結論', 'tags': '', 'url': '手足球系統模擬.html'}, {'title': 'V-rep 動態模擬', 'text': '', 'tags': '', 'url': 'V-rep 動態模擬.html'}, {'title': '送球機構模擬', 'text': '機構模擬測試 \n \n Ball sending not finish simulation \n \n 送球機構左右進洞 \n \n', 'tags': '', 'url': '送球機構模擬.html'}, {'title': '送球機構程式', 'text': '利用感測器感測到球，使平台下降到下方的感測器，球滾入後，平台上升，回到場內，繼續競賽 \n function sysCall_init()\n-- 定義參數\n    slider=sim.getObjectHandle(\'drive\')\n-- 定義物件 drive 驅動軸為 slider\n    down_Sensor=sim.getObjectHandle("sensor")\n-- 定義物件 sensor 感測器為 down_Sensor\n    down_Sensor_1=sim.getObjectHandle("sensor1")\n-- 定義物件 sensor1 感測器為 down_Sensor_1\n    up_Sensor=sim.getObjectHandle("sensor0")\n-- 定義物件 sensor0 感測器為 up_Sensor\n    speed=0\n-- 初始速度參數\n    A=-1\n-- 初始值\n    b=-1\n-- 初始值\nend\n\nfunction sysCall_actuation()\n    down=sim.readProximitySensor(down_Sensor)\n-- down 讀取 down_Sensor 感測器的狀態\n    down_1=sim.readProximitySensor(down_Sensor_1)\n-- down_1 讀取 down_Sensor_1 感測器的狀態\n    up=sim.readProximitySensor(up_Sensor)\n-- up 讀取 up_Sensor 感測器的狀態\n    if (down>0) or (down_1>0) \n-- 當感測器 down 或 down_1 觸發\n        then A=sim.getSimulationTime()+3 \n-- 設定 A = 模擬時間 + 3 秒 \n    end\n    if (A>0) \n        then sim.setJointTargetVelocity(slider,speed-0.08)\n-- slider 就會以速度 -0.08 向下移動\n    end\n    if (up>0) \n-- 當感測器 up 觸發\n        then b=sim.getSimulationTime()+3 \n-- 設定 b = 模擬時間 + 3 秒 \n    end\n    if (b>0) \n        then sim.setJointTargetVelocity(slider,speed+0.01)\n-- slider 就會以速度 0.01 向上移動\n    end\nend \n \n', 'tags': '', 'url': '送球機構程式.html'}, {'title': '手足球人對人模擬', 'text': '手足球模擬系統功能展示 (模擬展示與說明影片) \n left player simulation \n \n left player finish simulation \n \n left and right player simulation \n \n left1 and 2 player simulation \n \n Foosball \n \n Foosball - 測試雙人對打加送球機構 \n \n', 'tags': '', 'url': '手足球人對人模擬.html'}, {'title': '手足球人對人程式', 'text': 'left1 and left2\xa0Program \n -- model in Solvespace 500 mm = 5000 mm in V-rep\n--[[\nSimulation is 10 times of realistic environment\nfloor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep\nball is in Solivespace 1g (0.001) = 0.01 kg in V-rep\nhammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)\n]]\n\nthreadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==119) then\n                    -- up key\n                    velocity=100\n                    torque=200\n                    hammer_back = 0\n                end\n                if (auxiliaryData[1]==115) then\n                    -- down key\n                     hammer_back = 1\n                     torque=-200\n                     velocity = -100\n                end\n                if (auxiliaryData[1]==97) then\n                    -- right key\n                     sliding = sliding + 0.005\n                     sliding_1 = sliding_1 + 0.005\nsim.addStatusbarMessage(\'sliding:\'..sliding)\nsim.addStatusbarMessage(\'sliding_1:\'..sliding_1)  \n                end\n                if (auxiliaryData[1]==100) then\n                    -- left key\n                     sliding = sliding - 0.005\n                     sliding_1 = sliding_1 - 0.005\nsim.addStatusbarMessage(\'sliding:\'..sliding)\nsim.addStatusbarMessage(\'sliding_1:\'..sliding_1) \n                end\n                if (sliding < -0.0445) then\n                    sliding = -0.0445\n                elseif (sliding > 0.0445) then\n                    sliding = 0.0445\n                end\n                if (sliding_1 < -0.08255) then\n                    sliding_1 = -0.08255\n                elseif (sliding_1 > 0.08255) then\n                    sliding_1 = 0.08255\n                end\n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n \n        -- We take care of setting the desired hammer position:\n        if hammer_back == 1\n            then \n               sim.setJointPosition(joint, -1, orientation)\n               sim.setJointPosition(joint_1, -1, orientation)\n               --sim.setObjectPosition(hammer, -1, position)\n        end\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointTargetPosition(joint_1, velocity)\n        --sim.setJointForce(joint,torque)\n        sim.setJointTargetPosition(slider, sliding)\n        sim.setJointTargetPosition(slider_1, sliding_1)\n\n        -- Since this script is threaded, don\'t waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle(\'left_joint\')\nhammer=sim.getObjectHandle(\'left_player\')\nslider=sim.getObjectHandle("left_slider")\njoint_1=sim.getObjectHandle(\'left_joint_1\')\nhammer_1=sim.getObjectHandle(\'left_player_1\')\nslider_1=sim.getObjectHandle("left_slider_1")\nvelocity=0\nhammer_back=0\ntorque=0\nsliding = 0\nsliding_1 = 0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer, -1)\nslider_position=sim.getJointPosition(slider, -1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage(\'Lua runtime error: \'..err)\nend \n left3 and left4  \xa0Program \n -- model in Solvespace 500 mm = 5000 mm in V-rep\n--[[\nSimulation is 10 times of realistic environment\nfloor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep\nball is in Solivespace 1g (0.001) = 0.01 kg in V-rep\nhammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)\n]]\n\nthreadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==117) then\n                    -- up key\n                    velocity=100\n                    torque=200\n                    hammer_back = 0\n                end\n                if (auxiliaryData[1]==106) then\n                    -- down key\n                     hammer_back = 1\n                     torque=-200\n                     velocity = -100\n                end\n                if (auxiliaryData[1]==107) then\n                    -- right key\n                     sliding_2 = sliding_2 + 0.005\n                     sliding_3 = sliding_3 + 0.005\nsim.addStatusbarMessage(\'sliding_2:\'..sliding_2)\nsim.addStatusbarMessage(\'sliding_3:\'..sliding_3)  \n                end\n                if (auxiliaryData[1]==104) then\n                    -- left key\n                     sliding_2 = sliding_2 - 0.005\n                     sliding_3 = sliding_3 - 0.005\nsim.addStatusbarMessage(\'sliding_2:\'..sliding_2)\nsim.addStatusbarMessage(\'sliding_3:\'..sliding_3) \n                end\n                if (sliding_2 < -0.01905) then\n                    sliding_2 = -0.01905\n                elseif (sliding_2 > 0.01905) then\n                    sliding_2 = 0.01905\n                end\n                if (sliding_3 < -0.0635) then\n                    sliding_3 = -0.0635\n                elseif (sliding_3 > 0.0635) then\n                    sliding_3 = 0.0635\n                end\n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n \n        -- We take care of setting the desired hammer position:\n        if hammer_back == 1\n            then \n               sim.setJointPosition(joint, -1, orientation)\n               sim.setJointPosition(joint_1, -1, orientation)\n               --sim.setObjectPosition(hammer, -1, position)\n        end\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointTargetPosition(joint_1, velocity)\n        --sim.setJointForce(joint,torque)\n        sim.setJointTargetPosition(slider, sliding_2)\n        sim.setJointTargetPosition(slider_1, sliding_3)\n\n        -- Since this script is threaded, don\'t waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle(\'left_joint_2\')\nhammer=sim.getObjectHandle(\'left_player_2\')\nslider=sim.getObjectHandle("left_slider_2")\njoint_1=sim.getObjectHandle(\'left_joint_3\')\nhammer_1=sim.getObjectHandle(\'left_player_3\')\nslider_1=sim.getObjectHandle("left_slider_3")\nvelocity=0\nhammer_back=0\ntorque=0\nsliding_2 = 0\nsliding_3 = 0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer, -1)\nslider_position=sim.getJointPosition(slider, -1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage(\'Lua runtime error: \'..err)\nend \n right1 and right2 Program \n -- model in Solvespace 500 mm = 5000 mm in V-rep\n--[[\nSimulation is 10 times of realistic environment\nfloor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep\nball is in Solivespace 1g (0.001) = 0.01 kg in V-rep\nhammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)\n]]\n\nthreadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==2007) then\n                    -- up key\n                    velocity=100\n                    torque=200\n                    hammer_back = 0\n                end\n                if (auxiliaryData[1]==2008) then\n                    -- down key\n                     hammer_back = 1\n                     torque=-200\n                     velocity = -100\n                end\n                if (auxiliaryData[1]==2010) then\n                    -- right key\n                     sliding = sliding + 0.005\n                     sliding_1 = sliding_1 + 0.005\nsim.addStatusbarMessage(\'sliding:\'..sliding)\nsim.addStatusbarMessage(\'sliding_1:\'..sliding_1)  \n                end\n                if (auxiliaryData[1]==2009) then\n                    -- left key\n                     sliding = sliding - 0.005\n                     sliding_1 = sliding_1 - 0.005\nsim.addStatusbarMessage(\'sliding:\'..sliding)\nsim.addStatusbarMessage(\'sliding_1:\'..sliding_1) \n                end\n                if (sliding < -0.0445) then\n                    sliding = -0.0445\n                elseif (sliding > 0.0445) then\n                    sliding = 0.0445\n                end\n                if (sliding_1 < -0.08255) then\n                    sliding_1 = -0.08255\n                elseif (sliding_1 > 0.08255) then\n                    sliding_1 = 0.08255\n                end\n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n \n        -- We take care of setting the desired hammer position:\n        if hammer_back == 1\n            then \n               sim.setJointPosition(joint, -1, orientation)\n               sim.setJointPosition(joint_1, -1, orientation)\n               --sim.setObjectPosition(hammer, -1, position)\n        end\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointTargetPosition(joint_1, velocity)\n        --sim.setJointForce(joint,torque)\n        sim.setJointTargetPosition(slider, sliding)\n        sim.setJointTargetPosition(slider_1, sliding_1)\n\n        -- Since this script is threaded, don\'t waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle(\'right_joint\')\nhammer=sim.getObjectHandle(\'right_player\')\nslider=sim.getObjectHandle("right_slider")\njoint_1=sim.getObjectHandle(\'right_joint_1\')\nhammer_1=sim.getObjectHandle(\'right_player_1\')\nslider_1=sim.getObjectHandle("right_slider_1")\nvelocity=0\nhammer_back=0\ntorque=0\nsliding = 0\nsliding_1 = 0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer, -1)\nslider_position=sim.getJointPosition(slider, -1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage(\'Lua runtime error: \'..err)\nend \n left3 and left4 Program \n -- model in Solvespace 500 mm = 5000 mm in V-rep\n--[[\nSimulation is 10 times of realistic environment\nfloor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep\nball is in Solivespace 1g (0.001) = 0.01 kg in V-rep\nhammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)\n]]\n\nthreadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==56) then\n                    -- up key\n                    velocity=100\n                    torque=200\n                    hammer_back = 0\n                end\n                if (auxiliaryData[1]==53) then\n                    -- down key\n                     hammer_back = 1\n                     torque=-200\n                     velocity = -100\n                end\n                if (auxiliaryData[1]==54) then\n                    -- right key\n                     sliding_2 = sliding_2 + 0.005\n                     sliding_3 = sliding_3 + 0.005\nsim.addStatusbarMessage(\'sliding_2:\'..sliding_2)\nsim.addStatusbarMessage(\'sliding_3:\'..sliding_3)  \n                end\n                if (auxiliaryData[1]==52) then\n                    -- left key\n                     sliding_2 = sliding_2 - 0.005\n                     sliding_3 = sliding_3 - 0.005\nsim.addStatusbarMessage(\'sliding_2:\'..sliding_2)\nsim.addStatusbarMessage(\'sliding_3:\'..sliding_3) \n                end\n                if (sliding_2 < -0.01905) then\n                    sliding_2 = -0.01905\n                elseif (sliding_2 > 0.01905) then\n                    sliding_2 = 0.01905\n                end\n                if (sliding_3 < -0.0635) then\n                    sliding_3 = -0.0635\n                elseif (sliding_3 > 0.0635) then\n                    sliding_3 = 0.0635\n                end\n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n \n        -- We take care of setting the desired hammer position:\n        if hammer_back == 1\n            then \n               sim.setJointPosition(joint, -1, orientation)\n               sim.setJointPosition(joint_1, -1, orientation)\n               --sim.setObjectPosition(hammer, -1, position)\n        end\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointTargetPosition(joint_1, velocity)\n        --sim.setJointForce(joint,torque)\n        sim.setJointTargetPosition(slider, sliding_2)\n        sim.setJointTargetPosition(slider_1, sliding_3)\n\n        -- Since this script is threaded, don\'t waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle(\'right_joint_2\')\nhammer=sim.getObjectHandle(\'right_player_2\')\nslider=sim.getObjectHandle("right_slider_2")\njoint_1=sim.getObjectHandle(\'right_joint_3\')\nhammer_1=sim.getObjectHandle(\'right_player_3\')\nslider_1=sim.getObjectHandle("right_slider_3")\nvelocity=0\nhammer_back=0\ntorque=0\nsliding_2 = 0\nsliding_3 = 0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer, -1)\nslider_position=sim.getJointPosition(slider, -1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage(\'Lua runtime error: \'..err)\nend \n \n', 'tags': '', 'url': '手足球人對人程式.html'}, {'title': 'Final Report', 'text': '評分比例： \n 學員出席 (20%)： \n 20% \n Github 倉儲管理\xa0 (20%)： \n 16% \n Onshape 協同操作 (20%)： \n 6% \n V-rep 模擬 (20%)： \n 18 % \n 程式開發 (20%)： \n 18 % \n 總分：78', 'tags': '', 'url': 'Final Report.html'}]};