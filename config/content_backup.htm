<h1>執行規劃</h1>
<h2>手足球系統模擬</h2>
<p>專案成果摘要</p>
<p><span>我們這學期是做手足球的模擬，用 onshape 做協同設計，將繪製好的立體圖檔轉成 STL，丟到 vrep 進行動態模擬。我們對 " 人對人 "，" 人對電腦 "， " 電腦對電腦 " 及 " 送球機構 " 的模擬寫程式，使得手足球對打都能順利地模擬，送球機構採用升降台進行送球運動，在 vrep 模擬上也遇到了不少問題，花了很多時間去嘗試，最後也有將球順利送回球場上。</span></p>
<p>專案執行動機</p>
<p></p>
<p>相關文獻探討</p>
<p>專案執行成員</p>
<table border="1" style="border-color: #95e2f0; width: 528.2px;">
<tbody>
<tr style="height: 47px;">
<td style="text-align: center; width: 207px; height: 47px;"><strong>Leader</strong></td>
<td style="text-align: center; width: 320.2px; height: 47px;">
<pre class="tw-data-text tw-ta tw-text-large" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><strong><span lang="en">Assignments</span></strong></pre>
</td>
</tr>
<tr style="height: 141px;">
<td style="text-align: center; width: 207px; height: 141px;">
<p>40623203</p>
<p>蔡宜芳</p>
</td>
<td style="text-align: center; width: 320.2px; height: 141px;">
<p>執行規劃</p>
<p>V-rep  人對人模擬和程式</p>
<p><span>V-rep  送球機構模擬和程式</span></p>
</td>
</tr>
<tr style="height: 47px;">
<td style="text-align: center; width: 207px; height: 47px;"><strong>Member</strong></td>
<td style="text-align: center; width: 320.2px; height: 47px;">
<pre class="tw-data-text tw-ta tw-text-large" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><strong><span lang="en">Assignments</span></strong></pre>
</td>
</tr>
<tr style="height: 139px;">
<td style="text-align: center; width: 207px; height: 139px;">
<p>40623206</p>
<p>邱妍蓁</p>
</td>
<td style="text-align: center; width: 320.2px; height: 139px;">
<p>Onshape 繪製手足球台跟抬球機構</p>
<p>爆炸圖</p>
</td>
</tr>
<tr style="height: 139px;">
<td style="text-align: center; width: 207px; height: 139px;">
<p>40623211</p>
<p><span>王得榮</span></p>
</td>
<td style="text-align: center; width: 320.2px; height: 139px;">
<p>標註送球機構的圖面</p>
<p>PDF</p>
</td>
</tr>
<tr style="height: 140.6px;">
<td style="text-align: center; width: 207px; height: 140.6px;">
<p>40623212</p>
<p><span>魏有泉</span></p>
</td>
<td style="text-align: center; width: 320.2px; height: 140.6px;">零件表</td>
</tr>
<tr style="height: 47px;">
<td style="text-align: center; width: 207px; height: 47px;">
<p>40623216</p>
<p><span>楊士平</span></p>
</td>
<td style="text-align: center; width: 320.2px; height: 47px;"><span>標註手足球的圖面</span></td>
</tr>
<tr style="height: 47px;">
<td style="text-align: center; width: 207px; height: 47px;">
<p>40623221</p>
<p><span>蔡和勳</span></p>
</td>
<td style="text-align: center; width: 320.2px; height: 47px;">投影片</td>
</tr>
<tr style="height: 47px;">
<td style="text-align: center; width: 207px; height: 47px;">
<p>40623222</p>
<p><span>蔡博淮</span></p>
</td>
<td style="text-align: center; width: 320.2px; height: 47px;">尺寸分析</td>
</tr>
<tr style="height: 47px;">
<td style="text-align: center; width: 207px; height: 47px;">
<p>40623228</p>
<p><span>陳永錩</span></p>
</td>
<td style="text-align: center; width: 320.2px; height: 47px;"><span>V-rep  電腦對電腦模擬和程式</span></td>
</tr>
<tr style="height: 47px;">
<td style="text-align: center; width: 207px; height: 47px;">
<p>40623233</p>
<p><span>謝宗宏</span></p>
</td>
<td style="text-align: center; width: 320.2px; height: 47px;"><span>V-rep  人對電腦模擬和程式</span></td>
</tr>
<tr style="height: 47px;">
<td style="text-align: center; width: 207px; height: 47px;">
<p>40623240</p>
<p><span>何冠均</span></p>
</td>
<td style="text-align: center; width: 320.2px; height: 47px;">PDF</td>
</tr>
<tr style="height: 47px;">
<td style="text-align: center; width: 207px; height: 47px;">
<p>40623245</p>
<p><span>練峪愷</span></p>
</td>
<td style="text-align: center; width: 320.2px; height: 47px;">
<p>標註送球機構的圖面</p>
<p>PDF</p>
</td>
</tr>
</tbody>
</table>
<p>執行使用套件</p>
<p>Onshape：</p>
<p><b>Onshape</b><span> </span>is a<span> </span><a href="https://en.wikipedia.org/wiki/Computer-aided_design" title="Computer-aided design">computer-aided design</a><span> </span>(CAD)<span> </span><a href="https://en.wikipedia.org/wiki/Software" title="Software">software</a><span> </span>system, delivered over the Internet via a<span> </span><a class="mw-redirect" href="https://en.wikipedia.org/wiki/Software_as_a_Service" title="Software as a Service">Software as a Service</a><span> </span>(SAAS) model. It makes extensive use of<span> </span><a href="https://en.wikipedia.org/wiki/Cloud_computing" title="Cloud computing">cloud computing</a>, with compute-intensive processing and<span> </span><a href="https://en.wikipedia.org/wiki/Rendering_(computer_graphics)" title="Rendering (computer graphics)">rendering</a><span> </span>performed on<span> </span><a href="https://en.wikipedia.org/wiki/Internet" title="Internet">Internet</a>-based<span> </span><a href="https://en.wikipedia.org/wiki/Server_(computing)" title="Server (computing)">servers</a>, and users are able to interact with the system via a<span> </span><a href="https://en.wikipedia.org/wiki/Web_browser" title="Web browser">web browser</a><span> </span>or the<span> </span><a href="https://en.wikipedia.org/wiki/IOS" title="IOS">iOS</a><span> </span>and<span> </span><a href="https://en.wikipedia.org/wiki/Android_(operating_system)" title="Android (operating system)">Android</a><span> </span>apps.</p>
<p>Onshape allows teams to collaborate on a single shared design, the same way multiple writers can work together editing a shared document via cloud services.<span> </span>It is primarily focused on mechanical CAD (MCAD) and is used for product and machinery design across many industries, including<span> </span><a href="https://en.wikipedia.org/wiki/Consumer_electronics" title="Consumer electronics">consumer electronics</a>, mechanical<span> </span><a class="mw-redirect" href="https://en.wikipedia.org/wiki/Machinery" title="Machinery">machinery</a>,<span> </span><a class="mw-redirect" href="https://en.wikipedia.org/wiki/Medical_devices" title="Medical devices">medical devices</a>,<span> </span><a href="https://en.wikipedia.org/wiki/3D_printing" title="3D printing">3D printing</a>, machine parts, and industrial equipment.</p>
<p>Onshape upgrades are released directly to the web interface, and the software does not require maintenance work from the user.</p>
<p>Founded in 2012, Onshape is based in<span> </span><a href="https://en.wikipedia.org/wiki/Cambridge,_Massachusetts" title="Cambridge, Massachusetts">Cambridge, Massachusetts</a><span> </span>(USA), with offices in<span> </span><a href="https://en.wikipedia.org/wiki/Singapore" title="Singapore">Singapore</a><span> </span>and<span> </span><a class="mw-redirect" href="https://en.wikipedia.org/wiki/Pune,_India" title="Pune, India">Pune, India</a>.<span> </span>Its leadership team includes several engineers and executives who originated<span> </span><a href="https://en.wikipedia.org/wiki/SolidWorks" title="SolidWorks">SolidWorks</a>, a popular 3D CAD program that runs on Windows computers.<span> </span>Onshape’s co-founders include two former SolidWorks CEOs,<span> </span><a href="https://en.wikipedia.org/wiki/Jon_Hirschtick" title="Jon Hirschtick">Jon Hirschtick</a><span> </span>and John McEleney.</p>
<p>V-rep：</p>
<ol>
<li>V-REP provides a unified framework combining many powerful internal and external libraries that are often useful for robotics simulations. This includes dynamic simulation engines, forward/inverse kinematics tools, collision detection libraries, vision sensor simulations, path planning, GUI development tools, and built-in models of many common robots</li>
<li>V-REP is highly extensible. V-REP developers provide an API that allows one to write custom plugins that add new features. You can embed<span> </span><a class="external text" href="https://en.wikipedia.org/wiki/Lua_(programming_language)" rel="nofollow">Lua</a><span> </span>scripts directly into a simulation scene that, for example, process simulated sensor data, run control algorithms, implement user interfaces, or even send data to a physical robot. They also provide a remote API that allows one to develop standalone applications in many programming languages that are able to pass data in and out of a running V-REP simulation.</li>
</ol>
<p></p>
<p>專案執行過程規劃</p>
<p>專案執行內容</p>
<p>專案結論</p><h1>V-rep 動態模擬</h1>
<h2>送球機構模擬</h2>
<p><strong>機構模擬測試</strong></p>
<p><img alt="" height="429" src="/images/送球機構模擬.gif" width="800"/></p>
<p><strong>Ball sending not finish simulation</strong></p>
<p><strong><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/i_aKMCLqzlU" width="560"></iframe></strong></p>
<p><yt-formatted-string class="style-scope ytd-video-primary-info-renderer" force-default-style=""><b>送球機構左右進洞</b></yt-formatted-string></p>
<p><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="//www.youtube.com/embed/fYm1spOfMPs" width="560"></iframe></p>
<h2>送球機構程式</h2>
<p>利用感測器感測到球，使平台下降到下方的感測器，球滾入後，平台上升，回到場內，繼續競賽</p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
-- 定義參數
    slider=sim.getObjectHandle('drive')
-- 定義物件 drive 驅動軸為 slider
    down_Sensor=sim.getObjectHandle("sensor")
-- 定義物件 sensor 感測器為 down_Sensor
    down_Sensor_1=sim.getObjectHandle("sensor1")
-- 定義物件 sensor1 感測器為 down_Sensor_1
    up_Sensor=sim.getObjectHandle("sensor0")
-- 定義物件 sensor0 感測器為 up_Sensor
    speed=0
-- 初始速度參數
    A=-1
-- 初始值
    b=-1
-- 初始值
end

function sysCall_actuation()
    down=sim.readProximitySensor(down_Sensor)
-- down 讀取 down_Sensor 感測器的狀態
    down_1=sim.readProximitySensor(down_Sensor_1)
-- down_1 讀取 down_Sensor_1 感測器的狀態
    up=sim.readProximitySensor(up_Sensor)
-- up 讀取 up_Sensor 感測器的狀態
    if (down&gt;0) or (down_1&gt;0) 
-- 當感測器 down 或 down_1 觸發
        then A=sim.getSimulationTime()+3 
-- 設定 A = 模擬時間 + 3 秒 
    end
    if (A&gt;0) 
        then sim.setJointTargetVelocity(slider,speed-0.08)
-- slider 就會以速度 -0.08 向下移動
    end
    if (up&gt;0) 
-- 當感測器 up 觸發
        then b=sim.getSimulationTime()+3 
-- 設定 b = 模擬時間 + 3 秒 
    end
    if (b&gt;0) 
        then sim.setJointTargetVelocity(slider,speed+0.01)
-- slider 就會以速度 0.01 向上移動
    end
end</pre>
<p></p>
<h2>手足球人對人模擬</h2>
<p>手足球模擬系統功能展示 (模擬展示與說明影片)</p>
<p><strong>left player simulation</strong></p>
<p class="title style-scope ytd-video-primary-info-renderer"><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/0rHK7NbG45s" width="560"></iframe></p>
<p class="title style-scope ytd-video-primary-info-renderer"><strong>left player finish simulation</strong></p>
<p><strong><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/GkIYR4ygDyE" width="560"></iframe></strong><strong><br/></strong></p>
<p><strong>left and right player simulation</strong></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/N659eVjUabg" width="560"></iframe></p>
<p><yt-formatted-string class="style-scope ytd-video-primary-info-renderer" force-default-style="">left1 and 2 player simulation</yt-formatted-string></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/UScXj55MI0M" width="560"></iframe></p>
<p><yt-formatted-string class="style-scope ytd-video-primary-info-renderer" force-default-style="">Foosball</yt-formatted-string></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/K6szZBiRbtU" width="560"></iframe></p>
<p><yt-formatted-string class="style-scope ytd-video-primary-info-renderer" force-default-style="">Foosball - 測試雙人對打加送球機構</yt-formatted-string></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/ZRpXJjpKAno" width="560"></iframe></p>
<h2>手足球人對人程式</h2>
<p><strong>left1 and left2 Program</strong></p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">-- model in Solvespace 500 mm = 5000 mm in V-rep
--[[
Simulation is 10 times of realistic environment
floor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep
ball is in Solivespace 1g (0.001) = 0.01 kg in V-rep
hammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)
]]

threadFunction=function()
    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do
        -- Read the keyboard messages (make sure the focus is on the main window, scene view):
        message,auxiliaryData=sim.getSimulatorMessage()
        while message~=-1 do
            if (message==sim.message_keypress) then
                if (auxiliaryData[1]==119) then
                    -- up key
                    velocity=100
                    torque=200
                    hammer_back = 0
                end
                if (auxiliaryData[1]==115) then
                    -- down key
                     hammer_back = 1
                     torque=-200
                     velocity = -100
                end
                if (auxiliaryData[1]==97) then
                    -- right key
                     sliding = sliding + 0.005
                     sliding_1 = sliding_1 + 0.005
sim.addStatusbarMessage('sliding:'..sliding)
sim.addStatusbarMessage('sliding_1:'..sliding_1)  
                end
                if (auxiliaryData[1]==100) then
                    -- left key
                     sliding = sliding - 0.005
                     sliding_1 = sliding_1 - 0.005
sim.addStatusbarMessage('sliding:'..sliding)
sim.addStatusbarMessage('sliding_1:'..sliding_1) 
                end
                if (sliding &lt; -0.0445) then
                    sliding = -0.0445
                elseif (sliding &gt; 0.0445) then
                    sliding = 0.0445
                end
                if (sliding_1 &lt; -0.08255) then
                    sliding_1 = -0.08255
                elseif (sliding_1 &gt; 0.08255) then
                    sliding_1 = 0.08255
                end
            end
            message,auxiliaryData=sim.getSimulatorMessage()
        end
 
        -- We take care of setting the desired hammer position:
        if hammer_back == 1
            then 
               sim.setJointPosition(joint, -1, orientation)
               sim.setJointPosition(joint_1, -1, orientation)
               --sim.setObjectPosition(hammer, -1, position)
        end
        sim.setJointTargetPosition(joint, velocity)
        sim.setJointTargetPosition(joint_1, velocity)
        --sim.setJointForce(joint,torque)
        sim.setJointTargetPosition(slider, sliding)
        sim.setJointTargetPosition(slider_1, sliding_1)

        -- Since this script is threaded, don't waste time here:
        sim.switchThread() -- Resume the script at next simulation loop start
    end
end
-- Put some initialization code here:
-- Retrieving of some handles and setting of some initial values:
joint=sim.getObjectHandle('left_joint')
hammer=sim.getObjectHandle('left_player')
slider=sim.getObjectHandle("left_slider")
joint_1=sim.getObjectHandle('left_joint_1')
hammer_1=sim.getObjectHandle('left_player_1')
slider_1=sim.getObjectHandle("left_slider_1")
velocity=0
hammer_back=0
torque=0
sliding = 0
sliding_1 = 0
orientation=sim.getJointPosition(joint, -1)
position=sim.getObjectPosition(hammer, -1)
slider_position=sim.getJointPosition(slider, -1)
-- Here we execute the regular thread code:
res,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)
if not res then
    sim.addStatusbarMessage('Lua runtime error: '..err)
end</pre>
<p><strong>left3 and left4 <strong> Program</strong></strong></p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">-- model in Solvespace 500 mm = 5000 mm in V-rep
--[[
Simulation is 10 times of realistic environment
floor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep
ball is in Solivespace 1g (0.001) = 0.01 kg in V-rep
hammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)
]]

threadFunction=function()
    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do
        -- Read the keyboard messages (make sure the focus is on the main window, scene view):
        message,auxiliaryData=sim.getSimulatorMessage()
        while message~=-1 do
            if (message==sim.message_keypress) then
                if (auxiliaryData[1]==117) then
                    -- up key
                    velocity=100
                    torque=200
                    hammer_back = 0
                end
                if (auxiliaryData[1]==106) then
                    -- down key
                     hammer_back = 1
                     torque=-200
                     velocity = -100
                end
                if (auxiliaryData[1]==107) then
                    -- right key
                     sliding_2 = sliding_2 + 0.005
                     sliding_3 = sliding_3 + 0.005
sim.addStatusbarMessage('sliding_2:'..sliding_2)
sim.addStatusbarMessage('sliding_3:'..sliding_3)  
                end
                if (auxiliaryData[1]==104) then
                    -- left key
                     sliding_2 = sliding_2 - 0.005
                     sliding_3 = sliding_3 - 0.005
sim.addStatusbarMessage('sliding_2:'..sliding_2)
sim.addStatusbarMessage('sliding_3:'..sliding_3) 
                end
                if (sliding_2 &lt; -0.01905) then
                    sliding_2 = -0.01905
                elseif (sliding_2 &gt; 0.01905) then
                    sliding_2 = 0.01905
                end
                if (sliding_3 &lt; -0.0635) then
                    sliding_3 = -0.0635
                elseif (sliding_3 &gt; 0.0635) then
                    sliding_3 = 0.0635
                end
            end
            message,auxiliaryData=sim.getSimulatorMessage()
        end
 
        -- We take care of setting the desired hammer position:
        if hammer_back == 1
            then 
               sim.setJointPosition(joint, -1, orientation)
               sim.setJointPosition(joint_1, -1, orientation)
               --sim.setObjectPosition(hammer, -1, position)
        end
        sim.setJointTargetPosition(joint, velocity)
        sim.setJointTargetPosition(joint_1, velocity)
        --sim.setJointForce(joint,torque)
        sim.setJointTargetPosition(slider, sliding_2)
        sim.setJointTargetPosition(slider_1, sliding_3)

        -- Since this script is threaded, don't waste time here:
        sim.switchThread() -- Resume the script at next simulation loop start
    end
end
-- Put some initialization code here:
-- Retrieving of some handles and setting of some initial values:
joint=sim.getObjectHandle('left_joint_2')
hammer=sim.getObjectHandle('left_player_2')
slider=sim.getObjectHandle("left_slider_2")
joint_1=sim.getObjectHandle('left_joint_3')
hammer_1=sim.getObjectHandle('left_player_3')
slider_1=sim.getObjectHandle("left_slider_3")
velocity=0
hammer_back=0
torque=0
sliding_2 = 0
sliding_3 = 0
orientation=sim.getJointPosition(joint, -1)
position=sim.getObjectPosition(hammer, -1)
slider_position=sim.getJointPosition(slider, -1)
-- Here we execute the regular thread code:
res,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)
if not res then
    sim.addStatusbarMessage('Lua runtime error: '..err)
end</pre>
<p><strong>right1 and right2 Program</strong></p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">-- model in Solvespace 500 mm = 5000 mm in V-rep
--[[
Simulation is 10 times of realistic environment
floor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep
ball is in Solivespace 1g (0.001) = 0.01 kg in V-rep
hammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)
]]

threadFunction=function()
    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do
        -- Read the keyboard messages (make sure the focus is on the main window, scene view):
        message,auxiliaryData=sim.getSimulatorMessage()
        while message~=-1 do
            if (message==sim.message_keypress) then
                if (auxiliaryData[1]==2007) then
                    -- up key
                    velocity=100
                    torque=200
                    hammer_back = 0
                end
                if (auxiliaryData[1]==2008) then
                    -- down key
                     hammer_back = 1
                     torque=-200
                     velocity = -100
                end
                if (auxiliaryData[1]==2010) then
                    -- right key
                     sliding = sliding + 0.005
                     sliding_1 = sliding_1 + 0.005
sim.addStatusbarMessage('sliding:'..sliding)
sim.addStatusbarMessage('sliding_1:'..sliding_1)  
                end
                if (auxiliaryData[1]==2009) then
                    -- left key
                     sliding = sliding - 0.005
                     sliding_1 = sliding_1 - 0.005
sim.addStatusbarMessage('sliding:'..sliding)
sim.addStatusbarMessage('sliding_1:'..sliding_1) 
                end
                if (sliding &lt; -0.0445) then
                    sliding = -0.0445
                elseif (sliding &gt; 0.0445) then
                    sliding = 0.0445
                end
                if (sliding_1 &lt; -0.08255) then
                    sliding_1 = -0.08255
                elseif (sliding_1 &gt; 0.08255) then
                    sliding_1 = 0.08255
                end
            end
            message,auxiliaryData=sim.getSimulatorMessage()
        end
 
        -- We take care of setting the desired hammer position:
        if hammer_back == 1
            then 
               sim.setJointPosition(joint, -1, orientation)
               sim.setJointPosition(joint_1, -1, orientation)
               --sim.setObjectPosition(hammer, -1, position)
        end
        sim.setJointTargetPosition(joint, velocity)
        sim.setJointTargetPosition(joint_1, velocity)
        --sim.setJointForce(joint,torque)
        sim.setJointTargetPosition(slider, sliding)
        sim.setJointTargetPosition(slider_1, sliding_1)

        -- Since this script is threaded, don't waste time here:
        sim.switchThread() -- Resume the script at next simulation loop start
    end
end
-- Put some initialization code here:
-- Retrieving of some handles and setting of some initial values:
joint=sim.getObjectHandle('right_joint')
hammer=sim.getObjectHandle('right_player')
slider=sim.getObjectHandle("right_slider")
joint_1=sim.getObjectHandle('right_joint_1')
hammer_1=sim.getObjectHandle('right_player_1')
slider_1=sim.getObjectHandle("right_slider_1")
velocity=0
hammer_back=0
torque=0
sliding = 0
sliding_1 = 0
orientation=sim.getJointPosition(joint, -1)
position=sim.getObjectPosition(hammer, -1)
slider_position=sim.getJointPosition(slider, -1)
-- Here we execute the regular thread code:
res,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)
if not res then
    sim.addStatusbarMessage('Lua runtime error: '..err)
end</pre>
<p><strong>left3 and left4 Program</strong></p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">-- model in Solvespace 500 mm = 5000 mm in V-rep
--[[
Simulation is 10 times of realistic environment
floor in Solvespace 2.5 m x 2.5 m = 25 m x 25 m in V-rep
ball is in Solivespace 1g (0.001) = 0.01 kg in V-rep
hammer is in Solvespace 0.1 kg (100g) = 1kg in V-rep (0.1 for Inertia)
]]

threadFunction=function()
    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do
        -- Read the keyboard messages (make sure the focus is on the main window, scene view):
        message,auxiliaryData=sim.getSimulatorMessage()
        while message~=-1 do
            if (message==sim.message_keypress) then
                if (auxiliaryData[1]==56) then
                    -- up key
                    velocity=100
                    torque=200
                    hammer_back = 0
                end
                if (auxiliaryData[1]==53) then
                    -- down key
                     hammer_back = 1
                     torque=-200
                     velocity = -100
                end
                if (auxiliaryData[1]==54) then
                    -- right key
                     sliding_2 = sliding_2 + 0.005
                     sliding_3 = sliding_3 + 0.005
sim.addStatusbarMessage('sliding_2:'..sliding_2)
sim.addStatusbarMessage('sliding_3:'..sliding_3)  
                end
                if (auxiliaryData[1]==52) then
                    -- left key
                     sliding_2 = sliding_2 - 0.005
                     sliding_3 = sliding_3 - 0.005
sim.addStatusbarMessage('sliding_2:'..sliding_2)
sim.addStatusbarMessage('sliding_3:'..sliding_3) 
                end
                if (sliding_2 &lt; -0.01905) then
                    sliding_2 = -0.01905
                elseif (sliding_2 &gt; 0.01905) then
                    sliding_2 = 0.01905
                end
                if (sliding_3 &lt; -0.0635) then
                    sliding_3 = -0.0635
                elseif (sliding_3 &gt; 0.0635) then
                    sliding_3 = 0.0635
                end
            end
            message,auxiliaryData=sim.getSimulatorMessage()
        end
 
        -- We take care of setting the desired hammer position:
        if hammer_back == 1
            then 
               sim.setJointPosition(joint, -1, orientation)
               sim.setJointPosition(joint_1, -1, orientation)
               --sim.setObjectPosition(hammer, -1, position)
        end
        sim.setJointTargetPosition(joint, velocity)
        sim.setJointTargetPosition(joint_1, velocity)
        --sim.setJointForce(joint,torque)
        sim.setJointTargetPosition(slider, sliding_2)
        sim.setJointTargetPosition(slider_1, sliding_3)

        -- Since this script is threaded, don't waste time here:
        sim.switchThread() -- Resume the script at next simulation loop start
    end
end
-- Put some initialization code here:
-- Retrieving of some handles and setting of some initial values:
joint=sim.getObjectHandle('right_joint_2')
hammer=sim.getObjectHandle('right_player_2')
slider=sim.getObjectHandle("right_slider_2")
joint_1=sim.getObjectHandle('right_joint_3')
hammer_1=sim.getObjectHandle('right_player_3')
slider_1=sim.getObjectHandle("right_slider_3")
velocity=0
hammer_back=0
torque=0
sliding_2 = 0
sliding_3 = 0
orientation=sim.getJointPosition(joint, -1)
position=sim.getObjectPosition(hammer, -1)
slider_position=sim.getJointPosition(slider, -1)
-- Here we execute the regular thread code:
res,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)
if not res then
    sim.addStatusbarMessage('Lua runtime error: '..err)
end</pre>
<p></p>
<h1>Final Report</h1>
<p><span>評分比例：</span></p>
<p><span>學員出席 (20%)：</span></p>
<p><span>20%</span></p>
<p><span>Github 倉儲管理  (20%)：</span></p>
<p><span>16%</span></p>
<p>Onshape 協同操作 (20%)：</p>
<p><span>6%</span></p>
<p>V-rep 模擬 (20%)：</p>
<p>18<span>%</span></p>
<p>程式開發 (20%)：</p>
<p>18<span>%</span></p>
<p>總分：78</p>